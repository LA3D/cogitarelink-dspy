# Structured Agents and Pipelines


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

## Introduction

This notebook implements structured agent pipelines for the
Cogitarelink-DSPy integration. We’re creating agents that can reason
about semantic web data across different layers of abstraction:

1.  **Context Layer** - Working with JSON-LD contexts and namespaces
2.  **Ontology Layer** - Exploring ontologies and vocabularies
3.  **Rules Layer** - Validating data against rules (SHACL, etc.)
4.  **Instances Layer** - Working with actual data/triples
5.  **Verification Layer** - Verifying and signing data

In addition, we have a **Utility Layer** for cross-cutting concerns like
memory and telemetry.

Our approach uses DSPy’s `StructuredAgent` which provides a framework
for tool selection and execution based on the user’s query. We’ll
implement two levels of agents:

- `HelloLOD`: A lightweight agent with essential tools for common tasks
- `FullPlanner`: A comprehensive agent with all available tools

We’ll also integrate memory capabilities to enable the agent to learn
from previous experiences.

## System Prompts

The heart of our agent’s reasoning is the system prompt, which explains
the semantic web layers and how to select the appropriate tool based on
the user’s query. Let’s define the system prompts for our agents.

------------------------------------------------------------------------

<a
href="https://github.com/LA3D/cogitarelink-dspy/blob/main/cogitarelink_dspy/pipelines.py#L33"
target="_blank" style="float:right; font-size:smaller">source</a>

### get_memory_enhanced_system

>  get_memory_enhanced_system (reflection_prompt='')

\*Generate a system prompt enhanced with reflections from memory.

Args: reflection_prompt (str): Formatted reflections to include in the
prompt

Returns: str: The enhanced system prompt\*

## Available Tool Information

Let’s examine what tools are available from our component registry. This
helps us understand the capabilities we can provide to our agents.

``` python
# Examine available tools and layers (not exported)
tools = get_tools()
print(f"Available tools: {len(tools)}")

layers = list_layers()
print(f"\nAvailable layers: {', '.join(layers)}")

tools_by_layer = group_tools_by_layer(tools)
for layer, layer_tools in tools_by_layer.items():
    print(f"\n{layer} Layer: {len(layer_tools)} tools")
    for tool in layer_tools:
        print(f"  - {tool.__name__}: {tool.__doc__.split('[Layer')[0].strip()}")
```

    Available tools: 9

    Available layers: Context, Instances, Ontology, Rules, Utility, Verification

    Utility Layer: 4 tools
      - EchoMessage: Simply echoes the input message back.
      - AddReflection: Persist a reflection into semantic memory
      - RecallReflection: Retrieve recent reflection notes
      - ReflectionPrompt: Format recent notes for prompt injection

    Context Layer: 1 tools
      - LoadContext: Loads and processes JSON-LD contexts.

    Ontology Layer: 1 tools
      - FetchOntology: Accesses the vocabulary registry.

    Rules Layer: 1 tools
      - ValidateEntity: Validates an Entity against SHACL shapes.

    Instances Layer: 1 tools
      - GraphManager: Manages RDF graphs and triples.

    Verification Layer: 1 tools
      - VerifySignature: Verifies a digital signature on a named graph.

## HelloLOD: Lightweight Semantic Web Agent

Our `HelloLOD` agent is a minimal implementation that provides basic
semantic web functionality. It includes only the essential tools for
common tasks, making it faster and more focused than the full agent.

The key design decisions for HelloLOD are:

1.  Include one representative tool from each semantic layer
2.  Exclude memory tools initially for simplicity
3.  Use a straightforward system prompt without complex reflection

This agent serves as both a proof of concept and a starting point for
more complex implementations.

------------------------------------------------------------------------

<a
href="https://github.com/LA3D/cogitarelink-dspy/blob/main/cogitarelink_dspy/pipelines.py#L54"
target="_blank" style="float:right; font-size:smaller">source</a>

### build_hellolod

>  build_hellolod (lm=None)

\*Create a minimal Linked Open Data agent with basic capabilities.

This agent includes one representative tool from each semantic layer but
excludes memory tools for simplicity.

Args: lm (dspy.LM, optional): Language model to use. If None, must be
configured later.

Returns: dspy.StructuredAgent: A configured agent ready for use\*

## HelloLODWithMemory: Adding Reflection Capabilities

The next evolution of our agent adds memory capabilities through the
ReflectionStore. This allows the agent to:

1.  Store reflections about its experiences
2.  Recall previous reflections when making decisions
3.  Learn from past interactions

By incorporating memory, the agent can improve over time and avoid
repeating mistakes.

------------------------------------------------------------------------

<a
href="https://github.com/LA3D/cogitarelink-dspy/blob/main/cogitarelink_dspy/pipelines.py#L94"
target="_blank" style="float:right; font-size:smaller">source</a>

### build_hellolod_with_memory

>  build_hellolod_with_memory (lm=None, reflection_limit=5)

\*Create a Linked Open Data agent with memory capabilities.

This agent extends HelloLOD by adding memory tools for storing and
retrieving reflections about past experiences.

Args: lm (dspy.LM, optional): Language model to use. If None, must be
configured later. reflection_limit (int): Number of reflections to
include in the system prompt.

Returns: dspy.StructuredAgent: A configured agent with memory
capabilities\*

## FullPlanner: Comprehensive Semantic Web Agent

Our most capable agent, `FullPlanner`, includes all available tools and
advanced memory integration. This agent is designed for complex semantic
web tasks that require multiple tools and sophisticated reasoning.

Key features of the FullPlanner:

1.  Includes all tools from all semantic layers
2.  Full memory integration with reflection capabilities
3.  Enhanced system prompt with layer-specific reasoning
4.  Support for telemetry to track performance

This agent represents the full power of our semantic web framework.

------------------------------------------------------------------------

<a
href="https://github.com/LA3D/cogitarelink-dspy/blob/main/cogitarelink_dspy/pipelines.py#L151"
target="_blank" style="float:right; font-size:smaller">source</a>

### build_full_planner

>  build_full_planner (lm=None, reflection_limit=5)

\*Create a comprehensive semantic web agent with all available tools.

This agent includes all tools from all layers, along with memory
integration and enhanced reasoning capabilities.

Args: lm (dspy.LM, optional): Language model to use. If None, must be
configured later. reflection_limit (int): Number of reflections to
include in the system prompt.

Returns: dspy.StructuredAgent: A fully configured comprehensive agent\*

## Testing Helper Functions

To streamline testing and demonstration, we’ll create helper functions
that can run queries against our agents and display the results in a
structured format.

------------------------------------------------------------------------

<a
href="https://github.com/LA3D/cogitarelink-dspy/blob/main/cogitarelink_dspy/pipelines.py#L204"
target="_blank" style="float:right; font-size:smaller">source</a>

### run_test_query

>  run_test_query (agent, query, save_reflection=False,
>                      reflection_tags=None)

\*Run a test query through an agent and format the results.

This function runs a query through the specified agent and returns the
response along with metadata about tool usage and layer selection.
Optionally saves the interaction as a reflection for future reference.

Args: agent (dspy.StructuredAgent): The agent to query query (str): The
user query to process save_reflection (bool): Whether to save the
interaction as a reflection reflection_tags (list): Tags to apply to the
reflection

Returns: dict: Response and metadata about the interaction\*

## Complete Pipeline Factory

Finally, we’ll create a factory function that can produce any of our
agent types based on a configuration. This provides a clean interface
for applications to obtain the right agent for their needs.

------------------------------------------------------------------------

<a
href="https://github.com/LA3D/cogitarelink-dspy/blob/main/cogitarelink_dspy/pipelines.py#L260"
target="_blank" style="float:right; font-size:smaller">source</a>

### create_agent

>  create_agent (agent_type='hello', lm=None, reflection_limit=5)

\*Factory function to create different types of semantic web agents.

This function creates and returns the specified type of agent, handling
the configuration details for each variant.

Args: agent_type (str): Type of agent to create (‘hello’, ‘memory’, or
‘full’) lm (dspy.LM, optional): Language model to use. If None, must be
configured later. reflection_limit (int): Number of reflections to
include for memory-enabled agents.

Returns: dspy.StructuredAgent: The configured agent of the requested
type

Raises: ValueError: If an invalid agent_type is specified\*

## Example Usage

Let’s demonstrate how to use these agents with some example queries.
Note that you’ll need to configure a language model before running these
examples.

## Conclusion

In this notebook, we’ve implemented a layered approach to semantic web
agents using DSPy’s structured agent framework. The key components we’ve
created are:

1.  **System prompts** that explain the semantic web layers and guide
    tool selection
2.  **Agent implementations** at different capability levels (HelloLOD,
    HelloLODWithMemory, FullPlanner)
3.  **Memory integration** to learn from past interactions
4.  **Testing utilities** to validate agent behavior

These components form the foundation of our semantic web agent
architecture, enabling sophisticated reasoning across the different
layers of the semantic web stack. The agents can now be integrated into
applications to provide semantic web capabilities through natural
language interfaces.
