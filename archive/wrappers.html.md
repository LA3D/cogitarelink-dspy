# Tool Wrappers


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

------------------------------------------------------------------------

<a
href="https://github.com/LA3D/cogitarelink-dspy/blob/main/cogitarelink_dspy/wrappers.py#L15"
target="_blank" style="float:right; font-size:smaller">source</a>

### parse_signature

>  parse_signature (sig_str)

\*Parse a signature string like ‘foo(a:str, b:int) -\> str’ into
parameter names, types, and return type.

Handles complex types like List\[str\], Dict\[str, Any\], etc.

Args: sig_str: A string in the format “function_name(param1:type,
param2:type) -\> return_type” or just “param1:type, param2:type) -\>
return_type”

Returns: tuple: (list of (name, type) tuples for parameters,
return_type)\*

``` python
# Test the signature parser with more complex cases
test_signatures = [
    # Basic cases
    ("forward(message:str)", [("message", "str")], None),
    ("load(source:str) -> dict", [("source", "str")], "dict"),
    ("validate(subject:str, predicate:str, object:str)", 
     [("subject", "str"), ("predicate", "str"), ("object", "str")], None),
    ("verify(graph_id:str, signature:str) -> bool", 
     [("graph_id", "str"), ("signature", "str")], "bool"),
     
    # Complex types
    ("fetch(urls:List[str]) -> Dict[str, Any]",
     [("urls", "List[str]")], "Dict[str, Any]"),
    ("process(data:Dict[str, List[int]], options:Optional[Dict[str, bool]]=None) -> Tuple[int, str]",
     [("data", "Dict[str, List[int]]"), ("options", "Optional[Dict[str, bool]]=None")], "Tuple[int, str]"),
     
    # Edge cases
    ("complex_func(a:int, b:List[Tuple[str, int]], c:Dict[str, List[Dict[str, Any]]]) -> bool",
     [("a", "int"), ("b", "List[Tuple[str, int]]"), ("c", "Dict[str, List[Dict[str, Any]]]")], "bool")
]

for sig_str, expected_params, expected_return in test_signatures:
    params, return_type = parse_signature(sig_str)
    assert params == expected_params, f"For {sig_str}, expected params {expected_params}, got {params}"
    if expected_return:
        assert return_type == expected_return, f"For {sig_str}, expected return type {expected_return}, got {return_type}"
    
print("All signature parser tests passed!")
```

    All signature parser tests passed!

------------------------------------------------------------------------

<a
href="https://github.com/LA3D/cogitarelink-dspy/blob/main/cogitarelink_dspy/wrappers.py#L77"
target="_blank" style="float:right; font-size:smaller">source</a>

### make_tool_wrappers

>  make_tool_wrappers (registry={'Utils': {'layer': 'Utility', 'tool':
>                          'EchoMessage', 'doc': 'Simply echoes the input
>                          message back.', 'calls':
>                          'load_module_source(module_name:str,
>                          full_name:bool=False) -> str', 'module':
>                          'cogitarelink.utils'}, 'ContextProcessor': {'layer':
>                          'Context', 'tool': 'LoadContext', 'doc': 'Loads and
>                          processes JSON-LD contexts.', 'calls':
>                          'compact(doc:dict, ctx:dict) -> dict', 'module':
>                          'cogitarelink.core.context'}, 'VocabRegistry':
>                          {'layer': 'Ontology', 'tool': 'FetchOntology', 'doc':
>                          'Accesses the vocabulary registry.', 'calls':
>                          'resolve(uri:str) -> dict', 'module':
>                          'cogitarelink.vocab.registry'}, 'ValidateEntity':
>                          {'layer': 'Rules', 'tool': 'ValidateEntity', 'doc':
>                          'Validates an Entity against SHACL shapes.', 'calls':
>                          'validate_entity(target:str, shapes_graph:str) ->
>                          bool', 'module': 'cogitarelink.verify.validator'},
>                          'GraphManager': {'layer': 'Instances', 'tool':
>                          'GraphManager', 'doc': 'Manages RDF graphs and
>                          triples.', 'calls': 'query(q:str) -> dict', 'module':
>                          'cogitarelink.core.graph'}, 'Signer': {'layer':
>                          'Verification', 'tool': 'VerifySignature', 'doc':
>                          'Verifies a digital signature on a named graph.',
>                          'calls': 'verify(graph_id:str, signature:str) ->
>                          bool', 'module': 'cogitarelink.verify.signer'},
>                          'AddReflection': {'layer': 'Utility', 'tool':
>                          'AddReflection', 'doc': 'Persist a reflection into
>                          semantic memory', 'calls': 'add(text:str,
>                          tags:list=None)->str', 'module':
>                          'cogitarelink_dspy.memory'}, 'RecallReflection':
>                          {'layer': 'Utility', 'tool': 'RecallReflection',
>                          'doc': 'Retrieve recent reflection notes', 'calls':
>                          'retrieve(limit:int, tag_filter:str=None)->list',
>                          'module': 'cogitarelink_dspy.memory'},
>                          'ReflectionPrompt': {'layer': 'Utility', 'tool':
>                          'ReflectionPrompt', 'doc': 'Format recent notes for
>                          prompt injection', 'calls':
>                          'as_prompt(limit:int)->str', 'module':
>                          'cogitarelink_dspy.memory'}})

\*Generate DSPy Module classes for each tool in the registry.

Args: registry: Dictionary of component definitions with layer, tool,
doc, and calls fields

Returns: list: A list of DSPy Module classes, one for each component\*

------------------------------------------------------------------------

<a
href="https://github.com/LA3D/cogitarelink-dspy/blob/main/cogitarelink_dspy/wrappers.py#L244"
target="_blank" style="float:right; font-size:smaller">source</a>

### group_tools_by_layer

>  group_tools_by_layer (tools=None)

\*Group the generated tools by their semantic layer.

Args: tools: List of tool classes to group. If None, uses get_tools().

Returns: dict: A dictionary with layers as keys and lists of tools as
values\*

------------------------------------------------------------------------

<a
href="https://github.com/LA3D/cogitarelink-dspy/blob/main/cogitarelink_dspy/wrappers.py#L228"
target="_blank" style="float:right; font-size:smaller">source</a>

### get_tool_by_name

>  get_tool_by_name (tool_name)

\*Find a specific tool by its name.

Args: tool_name (str): The name of the tool to find

Returns: class or None: The tool class if found, None otherwise\*

------------------------------------------------------------------------

<a
href="https://github.com/LA3D/cogitarelink-dspy/blob/main/cogitarelink_dspy/wrappers.py#L217"
target="_blank" style="float:right; font-size:smaller">source</a>

### get_tools

>  get_tools ()

\*Get or initialize the tool wrappers.

Returns: list: A list of DSPy Module classes, one for each component\*

``` python
# Test the tool wrapper generation functionality
try:
    # Generate the tools
    tools = make_tool_wrappers()
    assert len(tools) == len(COMPONENTS), f"Expected {len(COMPONENTS)} tools, got {len(tools)}"
    
    # Test a sample tool
    for tool_class in tools[:1]:  # Just check the first tool
        print(f"Tool name: {tool_class.__name__}")
        print(f"Documentation: {tool_class.__doc__}")
        print(f"Layer: {tool_class.layer}")
        print(f"Module path: {tool_class.module_path}")
        
        # Create an instance and test it
        instance = tool_class()
        sample_args = {"message": "Testing tool wrapper"} if "message" in str(tool_class.signature) else {}
        print(f"\nCalling with: {sample_args}")
        try:
            result = instance(**sample_args)
            print(f"Result: {result}")
        except Exception as e:
            print(f"Error calling tool: {e}")
except Exception as e:
    print(f"Error testing tool wrappers: {e}")
    print("This is expected during notebook testing without all dependencies.")
```

    Tool name: EchoMessage
    Documentation: Simply echoes the input message back. [Layer: Utility]
    Layer: Utility
    Module path: cogitarelink.utils

    Calling with: {}
    Error calling EchoMessage: module 'cogitarelink' has no attribute 'Utils'
    Result: Mock result from EchoMessage with args: {}

## Using the Generated Tools

Each tool is a DSPy Module class that can be instantiated and used in a
DSPy pipeline. Here’s how to use the tools:

1.  **Individual Tool Usage**:
    - Instantiate a specific tool using its class
    - Call it with the appropriate parameters as defined in its
      signature
2.  **Layer-Based Tool Selection**:
    - Use the
      [`group_tools_by_layer()`](https://LA3D.github.io/cogitarelink-dspy/archive/wrappers.html#group_tools_by_layer)
      function to organize tools by layer
    - Select tools from the appropriate layer based on the user’s query
3.  **Integration with DSPy Agent**:
    - Pass the entire `TOOLS` list to a `dspy.StructuredAgent`
    - The agent will be able to discover and use the tools based on
      their signatures and documentation

``` python
# Example: Create an agent that can use our tools
def create_semantic_agent(lm=None):
    """Create a semantic agent with the generated tools.
    
    This function will eventually be moved to its own module. It's shown here
    as an illustration of how the tools will be used in a DSPy agent.
    """
    import dspy
    from cogitarelink_dspy.core import default_lm
    
    # Use the LLM from core if none is provided
    lm = lm or default_lm
    
    # Create a system prompt that explains the 4-layer architecture
    system_prompt = """
    You are a Semantic-Web agent that reasons over a 4-layer architecture:
    1. Context - Working with JSON-LD contexts and namespaces
    2. Ontology - Using vocabularies and ontology terms
    3. Rules - Applying validation rules and shapes
    4. Instances - Managing actual data instances
    5. Verification - Verifying and signing graph data
    
    Every tool is tagged with its PRIMARY layer. When answering a user question,
    pick the tool from the HIGHEST layer that suffices to answer the question.
    """
    
    semantic_lm = dspy.LM(lm.model, system=system_prompt) if lm else None
    
    # Create a StructuredAgent with our tools
    agent = dspy.StructuredAgent(
        tools=get_tools(),  # Get tools using the getter function
        lm=semantic_lm
    )
    
    return agent

# This will be implemented in a future notebook focused on the agent
# agent = create_semantic_agent() 
# result = agent.query("Load the schema.org context")
```
