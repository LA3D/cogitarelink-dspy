"""ReAct-based HelloLOD pipeline for Cogitarelink-DSPy"""
# AUTOGENERATED! File to edit: ../nbs/04_pipelines.ipynb

# %% export
import dspy, hashlib, datetime
from cogitarelink.core.graph import GraphManager
from cogitarelink_dspy.wrappers import get_tools
from cogitarelink_dspy.memory import ReflectionStore, REFLECTION_GRAPH
from cogitarelink_dspy.telemetry import TelemetryStore

# Initialize graph, memory, and telemetry
graph = GraphManager(use_rdflib=True)
mem = ReflectionStore(graph)
telemetry = TelemetryStore(graph)

# Gather all tools and append memory callables
TOOLS = get_tools()
TOOLS += [mem.add, mem.retrieve, mem.as_prompt]

# System prompt for ReAct agent
SEM_WEB_SYSTEM = (
    "You are a Linked-Data teaching assistant. "
    "Think step-by-step; choose the highest Cogitarelink layer that solves the task. "
    "Return only the final answer â€” never reveal your thought."
)

# Define the ReAct signature
sig = dspy.Signature(
    "query:str -> answer:str",
    instructions=SEM_WEB_SYSTEM
)

# Configure the LLM and instantiate the ReAct agent
lm = dspy.LM(
    "openai/o3",
    temperature=1.0,
    max_tokens=20000
)
dspy.configure(lm=lm)

agent = dspy.ReAct(
    signature=sig,
    tools=TOOLS,
    max_iters=4,
)

# %% export
class HelloLOD(dspy.Module):
    """Lightweight wrapper that logs scratch-pad hashes & provenance."""
    def __init__(self, agent, telemetry, mem):
        super().__init__()
        self.agent = agent
        self.telemetry = telemetry
        self.mem = mem

    def forward(self, query: str):
        t0 = datetime.datetime.utcnow()
        result = self.agent(query=query)
        t1 = datetime.datetime.utcnow()

        # Hash the hidden chain-of-thought (fallback to empty if unavailable)
        try:
            lm = self.agent.get_lm()
        except Exception:
            lm = None
        scratch = getattr(lm, "last_scratch", "") if lm is not None else ""
        digest = hashlib.sha256(scratch.encode()).hexdigest()
        self.telemetry.log("cot", digest, tool_iri="urn:agent:HelloLOD")

        # Log latency (milliseconds)
        latency_ms = (t1 - t0).total_seconds() * 1000
        self.telemetry.log("latency", latency_ms, tool_iri="urn:agent:HelloLOD")

        # Optional manual reflection
        if query.lower().startswith("remember:"):
            note = query.split("remember:", 1)[1].strip()
            self.mem.add(note, tags=["manual"])
            return {"answer": f"Stored: {note}"}

        return result

# %% export
# Create default HelloLOD instance
hello = HelloLOD(agent, telemetry, mem)