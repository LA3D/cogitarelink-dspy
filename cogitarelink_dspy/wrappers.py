"""Automatically generate DSPy modules from our component registry."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_wrappers.ipynb.

# %% auto 0
__all__ = ['TOOLS', 'parse_signature', 'make_tool_wrappers', 'get_tools', 'get_tool_by_name', 'group_tools_by_layer']

# %% ../nbs/02_wrappers.ipynb 3
import re
import inspect
import dspy
from .components import  COMPONENTS

# %% ../nbs/02_wrappers.ipynb 4
def parse_signature(sig_str):
    """Parse a signature string like 'foo(a:str, b:int) -> str' into parameter names,
    types, and return type.
    
    Handles complex types like List[str], Dict[str, Any], etc.
    
    Args:
        sig_str: A string in the format "function_name(param1:type, param2:type) -> return_type"
                 or just "param1:type, param2:type) -> return_type"
                 
    Returns:
        tuple: (list of (name, type) tuples for parameters, return_type)
    """
    # Extract the part inside parentheses if it's a full function signature
    if '(' in sig_str:
        # Handle function name and everything inside parentheses
        fn_part = sig_str.split('(', 1)
        params_str = fn_part[1].split(')', 1)[0]
    else:
        params_str = sig_str.split(')', 1)[0]
        
    # Extract return type if present
    return_type = None
    if ' -> ' in sig_str:
        return_type = sig_str.split(' -> ')[1].strip()
    
    # Parse parameters - handle complex types with brackets which may contain commas
    params = []
    if params_str.strip():
        # First, handle nested types with braces that might contain commas
        processed_params = []
        param_buffer = ""
        bracket_level = 0
        
        for char in params_str:
            if char == ',' and bracket_level == 0:
                processed_params.append(param_buffer.strip())
                param_buffer = ""
            else:
                param_buffer += char
                if char == '[' or char == '{':
                    bracket_level += 1
                elif char == ']' or char == '}':
                    bracket_level -= 1
        
        # Add the last parameter if buffer is not empty
        if param_buffer.strip():
            processed_params.append(param_buffer.strip())
        
        # Now parse each parameter
        for param in processed_params:
            param = param.strip()
            if ':' in param:
                name, type_hint = param.split(':', 1)  # Split on first colon only
                params.append((name.strip(), type_hint.strip()))
            else:
                # If no type hint, default to str
                params.append((param.strip(), 'str'))
    
    return params, return_type

# %% ../nbs/02_wrappers.ipynb 6
def make_tool_wrappers(registry=COMPONENTS):
    """Generate DSPy Module classes for each tool in the registry.
    
    Args:
        registry: Dictionary of component definitions with layer, tool, doc, and calls fields
                 
    Returns:
        list: A list of DSPy Module classes, one for each component
    """
    tools = []
    
    for name, meta in registry.items():
        # Create a function to define tool class - prevents closure capture bug
        def create_tool_class(name, meta):
            # Get call signature from the component metadata
            call_sig = meta["calls"]
            params, return_type = parse_signature(call_sig)
            
            # Create signature string for DSPy - handle complex types by simplifying
            # Replace complex types with simpler types that DSPy can handle
            simplified_params = []
            for param_name, param_type in params:
                # Simplify complex types to basic types DSPy can understand
                if 'Entity' in param_type or 'Union' in param_type:
                    simplified_type = 'str'
                elif any(t in param_type for t in ['List', 'Dict', 'Tuple']):
                    simplified_type = 'dict'
                else:
                    simplified_type = param_type
                simplified_params.append((param_name, simplified_type))
            
            # Use simplified parameters for DSPy signature
            param_sig = ", ".join(f"{p[0]}:{p[1]}" for p in simplified_params)
            output_type = "str" if return_type and "Entity" in return_type else (return_type or "output")
            signature_str = f"{param_sig} -> {output_type}"
            
            # Documentation for the tool and build its signature
            class_doc = f"{meta['doc']} [Layer: {meta['layer']}]"
            # Generate the DSPy Signature class and instantiate it
            try:
                sig_cls = dspy.Signature(signature_str, "Tool wrapper signature")
            except Exception:
                # Fallback to an empty signature if parsing fails
                sig_cls = dspy.Signature({}, "Tool wrapper signature")
            # Instantiate the signature, falling back to Echo.signature if needed
            try:
                sig_instance = sig_cls()
            except Exception:
                # Fallback to an empty Signature subclass instance to avoid required fields
                class EmptySig(dspy.Signature):
                    """Empty Signature with no fields"""
                    pass
                sig_instance = EmptySig()
            # Define the DSPy Module class for this tool
            class ToolWrapper(dspy.Module):
                """Placeholder docstring that will be replaced."""
                # Assign the signature instance directly
                signature = sig_instance
                
                def forward(self, **kwargs):
                    """Forward the call to the actual implementation."""
                    try:
                        # Attempt to import the actual module
                        module_path = meta['module']
                        components = module_path.split('.')
                        
                        # Handle different module structures
                        # Case 1: function directly in module (like cogitarelink.verify.validator.validate_entity)
                        if len(components) > 1:
                            # Import parent module first
                            parent_module_path = '.'.join(components[:-1])
                            import importlib
                            parent_module = importlib.import_module(parent_module_path)
                            
                            try:
                                # Try to get the function from the parent module
                                function_name = call_sig.split('(')[0]
                                func = getattr(parent_module, function_name)
                                return func(**kwargs)
                            except (AttributeError, IndexError):
                                # Try to get the class if function not found
                                class_name = components[-1].capitalize()
                                class_obj = getattr(parent_module, class_name)
                                instance = class_obj()
                                
                                # Get method name from call_sig
                                method_name = call_sig.split('(')[0]
                                method = getattr(instance, method_name)
                                return method(**kwargs)
                        
                        # Case 2: Class needs to be instantiated first
                        else:
                            # Import the module
                            import importlib
                            module = importlib.import_module(module_path)
                            
                            # Get the class name from the component name
                            class_name = name
                            class_obj = getattr(module, class_name)
                            
                            # Create an instance
                            instance = class_obj()
                            
                            # Get the method name from call signature
                            method_name = call_sig.split('(')[0]
                            method = getattr(instance, method_name)
                            
                            # Call the method
                            return method(**kwargs)
                    
                    except Exception as e:
                        # Just log and return a fallback response for now
                        print(f"Error calling {meta['tool']}: {e}")
                        return f"Mock result from {meta['tool']} with args: {kwargs}"
            
            # Set proper class name and docstring
            ToolWrapper.__doc__ = class_doc
            ToolWrapper.__name__ = meta['tool']
            ToolWrapper.__qualname__ = meta['tool']
            
            # Store original parameter info as class attributes for reference
            ToolWrapper.original_params = params
            ToolWrapper.original_return_type = return_type
            
            # Add layer as a class attribute for easier access
            ToolWrapper.layer = meta['layer']
            ToolWrapper.module_path = meta.get('module', '')
            
            return ToolWrapper
        
        # Create the tool class and add to tools list
        tool_class = create_tool_class(name, meta)
        tools.append(tool_class)
    
    return tools

# %% ../nbs/02_wrappers.ipynb 7
# Initialize tool wrappers at import time
TOOLS = make_tool_wrappers()

def get_tools():
    """Get or initialize the tool wrappers.
    
    Returns:
        list: A list of DSPy Module classes, one for each component
    """
    global TOOLS
    if TOOLS is None:
        TOOLS = make_tool_wrappers()
    return TOOLS

def get_tool_by_name(tool_name):
    """Find a specific tool by its name.
    
    Args:
        tool_name (str): The name of the tool to find
        
    Returns:
        class or None: The tool class if found, None otherwise
    """
    tools = get_tools()
    for tool in tools:
        if tool.__name__ == tool_name:
            return tool
    return None

# Helper function to organize tools by layer
def group_tools_by_layer(tools=None):
    """Group the generated tools by their semantic layer.
    
    Args:
        tools: List of tool classes to group. If None, uses get_tools().
        
    Returns:
        dict: A dictionary with layers as keys and lists of tools as values
    """
    if tools is None:
        tools = get_tools()
        
    result = {}
    for tool in tools:
        # Get layer directly from the class attribute we added
        layer = tool.layer
        if layer not in result:
            result[layer] = []
        result[layer].append(tool)
    return result
