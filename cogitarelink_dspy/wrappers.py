"""Automatically generate DSPy modules from our component registry."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_wrappers.ipynb.

# %% auto 0
__all__ = ['TOOLS', 'parse_signature', 'make_tool_wrappers', 'get_tools', 'group_tools_by_layer']

# %% ../nbs/02_wrappers.ipynb 3
import re
import inspect
import dspy
from .components import COMPONENTS

# %% ../nbs/02_wrappers.ipynb 4
def parse_signature(sig_str):
    """Parse a signature string like 'foo(a:str, b:int) -> str' into parameter names,
    types, and return type.
    
    Args:
        sig_str: A string in the format "function_name(param1:type, param2:type) -> return_type"
                 or just "param1:type, param2:type) -> return_type"
                 
    Returns:
        tuple: (list of (name, type) tuples for parameters, return_type)
    """
    # Extract the part inside parentheses if it's a full function signature
    if '(' in sig_str:
        params_str = sig_str.split('(')[1].split(')')[0]
    else:
        params_str = sig_str
        
    # Extract return type if present
    return_type = None
    if ' -> ' in sig_str:
        return_type = sig_str.split(' -> ')[1].strip()
        
    # Parse parameters
    params = []
    if params_str.strip():
        for param in params_str.split(','):
            param = param.strip()
            if ':' in param:
                name, type_hint = param.split(':')
                params.append((name.strip(), type_hint.strip()))
            else:
                # If no type hint, default to str
                params.append((param.strip(), 'str'))
    
    return params, return_type

# %% ../nbs/02_wrappers.ipynb 6
def make_tool_wrappers(registry=COMPONENTS):
    """Generate DSPy Module classes for each tool in the registry.
    
    Args:
        registry: Dictionary of component definitions with layer, tool, doc, and calls fields
                 
    Returns:
        list: A list of DSPy Module classes, one for each component
    """
    tools = []
    
    for name, meta in registry.items():
        # Get call signature from the component metadata
        call_sig = meta["calls"]
        params, return_type = parse_signature(call_sig)
        
        # Create signature string for DSPy
        # Add commas between parameters for DSPy's signature parser
        param_sig = ", ".join(f"{p[0]}:{p[1]}" for p in params)
        output_type = return_type if return_type else "output"
        signature_str = f"{param_sig} -> {output_type}"
        
        # Create a new DSPy Module class with documentation and layer info
        class_doc = f"{meta['doc']} [Layer: {meta['layer']}]"
        
        class ToolWrapper(dspy.Module):
            """Placeholder docstring that will be replaced."""
            signature = dspy.Signature(signature_str)
            
            def forward(self, **kwargs):
                # This is just a stub - would actually call real implementation
                print(f"Called {meta['tool']} with args: {kwargs}")
                return f"Result from {meta['tool']}"
        
        # Set proper class name and docstring
        ToolWrapper.__doc__ = class_doc
        ToolWrapper.__name__ = meta['tool']
        ToolWrapper.__qualname__ = meta['tool']
        
        tools.append(ToolWrapper)
    
    return tools

# %% ../nbs/02_wrappers.ipynb 7
# Delay tool generation until explicitly called
TOOLS = None

def get_tools():
    """Get or initialize the tool wrappers.
    
    Returns:
        list: A list of DSPy Module classes, one for each component
    """
    global TOOLS
    if TOOLS is None:
        TOOLS = make_tool_wrappers()
    return TOOLS

# Helper function to organize tools by layer
def group_tools_by_layer(tools=None):
    """Group the generated tools by their semantic layer.
    
    Args:
        tools: List of tool classes to group. If None, uses get_tools().
        
    Returns:
        dict: A dictionary with layers as keys and lists of tools as values
    """
    if tools is None:
        tools = get_tools()
        
    result = {}
    for tool in tools:
        # Extract layer from the docstring
        doc = tool.__doc__
        layer_match = re.search(r'\[Layer: ([^\]]+)\]', doc)
        if layer_match:
            layer = layer_match.group(1)
            if layer not in result:
                result[layer] = []
            result[layer].append(tool)
    return result
