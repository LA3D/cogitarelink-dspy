"""Creating DSPy StructuredAgents for Semantic Web tasks"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_pipeline.ipynb.

# %% auto 0
__all__ = ['SEMANTIC_WEB_SYSTEM', 'make_hello_agent', 'get_memory_enhanced_system', 'build_hellolod',
           'build_hellolod_with_memory', 'build_full_planner', 'run_test_query', 'create_agent']

# %% ../nbs/01_pipeline.ipynb 3
import dspy
from typing import List, Dict, Any, Optional
from .wrappers import get_tools, get_tool_by_name, group_tools_by_layer
from .components import list_layers

# %% ../nbs/01_pipeline.ipynb 6
# Basic system prompt explaining the semantic web layers
SEMANTIC_WEB_SYSTEM = '''
You are a Semantic Web agent that reasons across these layers:

1. Context - JSON-LD context operations (namespaces, compaction)
2. Ontology - Vocabulary operations (term resolution, class hierarchies)
3. Rules - Validation and inference rules (SHACL shapes)
4. Instances - Data instance operations (SPARQL queries, graph updates)
5. Verification - Cryptographic operations (signing, verifying)

For each user query, identify the HIGHEST appropriate layer to address it.
Example 1: "What does schema:name mean?" → Ontology layer (vocabulary term)
Example 2: "Is this JSON-LD valid?" → Context layer (JSON-LD structure)
Example 3: "Does this person match the requirements?" → Rules layer (validation)
'''

# Enhanced system prompt with memory integration
def get_memory_enhanced_system(reflection_prompt=""):
    """
    Generate a system prompt enhanced with reflections from memory.
    
    Args:
        reflection_prompt (str): Formatted reflections to include in the prompt
        
    Returns:
        str: The enhanced system prompt
    """
    memory_section = ""
    if reflection_prompt and reflection_prompt.strip():
        memory_section = f"""
## Reflections from previous interactions
Consider these lessons from past interactions:
{reflection_prompt}
"""
    
    return SEMANTIC_WEB_SYSTEM + memory_section

# %% ../nbs/01_pipeline.ipynb 10
def build_hellolod(lm=None):
    """
    Create a minimal Linked Open Data agent with basic capabilities.
    
    This agent includes one representative tool from each semantic layer
    but excludes memory tools for simplicity.
    
    Args:
        lm (dspy.LM, optional): Language model to use. If None, must be configured later.
        
    Returns:
        dspy.StructuredAgent: A configured agent ready for use
    """
    # Select one tool from each semantic layer
    selected_tools = [
        get_tool_by_name("LoadContext"),      # Context layer
        get_tool_by_name("FetchOntology"),    # Ontology layer
        get_tool_by_name("ValidateEntity"),   # Rules layer
        get_tool_by_name("GraphManager"),     # Instances layer
        get_tool_by_name("VerifySignature"),  # Verification layer
    ]
    
    # Add EchoMessage as a basic utility
    echo_tool = get_tool_by_name("EchoMessage")
    if echo_tool:
        selected_tools.append(echo_tool)
    
    # Filter out any None values (in case a tool wasn't found)
    selected_tools = [t for t in selected_tools if t is not None]
    
    # Create the structured agent
    agent = dspy.StructuredAgent(
        tools=selected_tools,
        lm=lm,
        system=SEMANTIC_WEB_SYSTEM
    )
    
    return agent

# %% ../nbs/01_pipeline.ipynb 12
def build_hellolod_with_memory(lm=None, reflection_limit=5):
    """
    Create a Linked Open Data agent with memory capabilities.
    
    This agent extends HelloLOD by adding memory tools for storing and
    retrieving reflections about past experiences.
    
    Args:
        lm (dspy.LM, optional): Language model to use. If None, must be configured later.
        reflection_limit (int): Number of reflections to include in the system prompt.
        
    Returns:
        dspy.StructuredAgent: A configured agent with memory capabilities
    """
    # Start with the basic HelloLOD tools
    basic_tools = [
        get_tool_by_name("LoadContext"),      # Context layer
        get_tool_by_name("FetchOntology"),    # Ontology layer
        get_tool_by_name("ValidateEntity"),   # Rules layer
        get_tool_by_name("GraphManager"),     # Instances layer
        get_tool_by_name("VerifySignature"),  # Verification layer
        get_tool_by_name("EchoMessage"),      # Utility layer
    ]
    
    # Add memory tools
    memory_tools = [
        get_tool_by_name("AddReflection"),     # Store reflections
        get_tool_by_name("RecallReflection"),  # Retrieve reflections
        get_tool_by_name("ReflectionPrompt"),  # Format reflections for prompts
    ]
    
    # Combine and filter tools
    all_tools = basic_tools + memory_tools
    all_tools = [t for t in all_tools if t is not None]
    
    # Create an initial agent to get reflections
    reflection_prompt = ""
    try:
        # Try to get reflections from the store
        prompt_tool = get_tool_by_name("ReflectionPrompt")
        if prompt_tool:
            prompt_instance = prompt_tool()
            reflection_prompt = prompt_instance(limit=reflection_limit)
    except Exception as e:
        print(f"Warning: Could not retrieve reflections: {e}")
    
    # Create the agent with memory-enhanced system prompt
    system_prompt = get_memory_enhanced_system(reflection_prompt)
    agent = dspy.StructuredAgent(
        tools=all_tools,
        lm=lm,
        system=system_prompt
    )
    
    return agent

# %% ../nbs/01_pipeline.ipynb 14
def build_full_planner(lm=None, reflection_limit=5):
    """
    Create a comprehensive semantic web agent with all available tools.
    
    This agent includes all tools from all layers, along with memory
    integration and enhanced reasoning capabilities.
    
    Args:
        lm (dspy.LM, optional): Language model to use. If None, must be configured later.
        reflection_limit (int): Number of reflections to include in the system prompt.
        
    Returns:
        dspy.StructuredAgent: A fully configured comprehensive agent
    """
    # Get all available tools
    all_tools = get_tools()
    
    # Try to get reflections for the system prompt
    reflection_prompt = ""
    try:
        prompt_tool = get_tool_by_name("ReflectionPrompt")
        if prompt_tool:
            prompt_instance = prompt_tool()
            reflection_prompt = prompt_instance(limit=reflection_limit)
    except Exception as e:
        print(f"Warning: Could not retrieve reflections: {e}")
    
    # Create enhanced system prompt with tool-specific guidance
    layers = list_layers()
    tools_by_layer = group_tools_by_layer(all_tools)
    
    # Build layer-specific guidance
    layer_guidance = ""
    for layer in layers:
        if layer in tools_by_layer and tools_by_layer[layer]:
            layer_tools = tools_by_layer[layer]
            tool_names = ", ".join([t.__name__ for t in layer_tools])
            layer_guidance += f"\n- {layer} Layer: {tool_names}"
    
    # Enhanced system prompt with layer/tool mappings
    extended_system = f"{SEMANTIC_WEB_SYSTEM}\n\nAvailable tools by layer:{layer_guidance}"
    system_prompt = get_memory_enhanced_system(reflection_prompt).replace(SEMANTIC_WEB_SYSTEM, extended_system)
    
    # Create the full agent
    agent = dspy.StructuredAgent(
        tools=all_tools,
        lm=lm,
        system=system_prompt
    )
    
    return agent

# %% ../nbs/01_pipeline.ipynb 16
def run_test_query(agent, query, save_reflection=False, reflection_tags=None):
    """
    Run a test query through an agent and format the results.
    
    This function runs a query through the specified agent and returns
    the response along with metadata about tool usage and layer selection.
    Optionally saves the interaction as a reflection for future reference.
    
    Args:
        agent (dspy.StructuredAgent): The agent to query
        query (str): The user query to process
        save_reflection (bool): Whether to save the interaction as a reflection
        reflection_tags (list): Tags to apply to the reflection
        
    Returns:
        dict: Response and metadata about the interaction
    """
    # Default tags if none provided
    if reflection_tags is None:
        reflection_tags = ["test"]
    
    # Process the query
    try:
        response = agent(query)
    except Exception as e:
        return {"error": str(e), "query": query}
    
    # Extract metadata
    result = {
        "query": query,
        "response": response.get("response", "No response"),
        "tool_used": response.get("tool", "None"),
        "layer_detected": None,  # Will fill this in
    }
    
    # Determine the layer
    if result["tool_used"] != "None":
        tool_class = get_tool_by_name(result["tool_used"])
        if tool_class:
            result["layer_detected"] = tool_class.layer
    
    # Save reflection if requested
    if save_reflection and result["tool_used"] != "None":
        try:
            add_reflection = get_tool_by_name("AddReflection")
            if add_reflection:
                reflection_tool = add_reflection()
                reflection_text = f"For query '{query}', used {result['tool_used']} from {result['layer_detected']} layer."
                reflection_id = reflection_tool(text=reflection_text, tags=reflection_tags)
                result["reflection_id"] = reflection_id
        except Exception as e:
            result["reflection_error"] = str(e)
    
    return result

# %% ../nbs/01_pipeline.ipynb 18
def create_agent(agent_type="hello", lm=None, reflection_limit=5):
    """
    Factory function to create different types of semantic web agents.
    
    This function creates and returns the specified type of agent,
    handling the configuration details for each variant.
    
    Args:
        agent_type (str): Type of agent to create ('hello', 'memory', or 'full')
        lm (dspy.LM, optional): Language model to use. If None, must be configured later.
        reflection_limit (int): Number of reflections to include for memory-enabled agents.
        
    Returns:
        dspy.StructuredAgent: The configured agent of the requested type
        
    Raises:
        ValueError: If an invalid agent_type is specified
    """
    if agent_type.lower() in ["hello", "basic", "hellolod"]:
        return build_hellolod(lm)
    elif agent_type.lower() in ["memory", "hellolodwithmemory"]:
        return build_hellolod_with_memory(lm, reflection_limit)
    elif agent_type.lower() in ["full", "fullplanner"]:
        return build_full_planner(lm, reflection_limit)
    else:
        raise ValueError(f"Unknown agent type: {agent_type}. Use 'hello', 'memory', or 'full'.")

# Legacy name for backward compatibility
make_hello_agent = create_agent
